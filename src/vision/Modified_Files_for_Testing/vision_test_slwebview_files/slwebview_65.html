<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>validation_gate_test/Convert to BW/Identify Validation Gate1</title></head><link rel="StyleSheet" href="slwebview.css" type="text/css"><script type="text/javascript" src="id_mapping.js"></script><script type="text/javascript" src="slwebview.js"></script><script type="text/javascript" src="slwebview_utils.js"></script><script type="text/javascript" src="slhtmltoolbar.js"></script><body onload="addToolbar('toolbarDiv');"><table><tr><td><div id="toolbarDiv" style="display:inline"></div></td><td class="content" style="vertical-align:middle">Identify Validation Gate1</td></tr></table><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd"><span style="color:blue">function</span> [theta_out, rho_out, target_y, target_z, gate_found] = hue_filter(bw_image_in, hough_table, theta_in, rho_in, threshold, target_height, gate_aspect_ratio)
<span style="color:green">%#eml</span>

<span style="color:green">% This function attempts to identfiy the validation gate, and returns line</span>
<span style="color:green">%   information, targeting information, and a true/false gate_found</span>
<span style="color:green">%   parameter.</span>
<span style="color:green">%</span>
<span style="color:green">% 5-29-11</span>
<span style="color:green">%</span>
<span style="color:green">% Input</span>
<span style="color:green">%</span>
<span style="color:green">%   target_height = fraction of goal post height to aim AUV at</span>
<span style="color:green">%   gate_aspect_ratio = used to infer unknown points with little extra</span>
<span style="color:green">%     processing (height/width of large T-shape)</span>
<span style="color:green">%</span>
<span style="color:green">% Output</span>
<span style="color:green">%</span>
<span style="color:green">% Notes:</span>
<span style="color:green">%   The hough_table is destroyed in this function (acceptable if</span>
<span style="color:green">%     hough_table is not an output)</span>
<span style="color:green">%   Process:</span>
<span style="color:green">%     1. Identify primary, relatively "long" lines</span>
<span style="color:green">%     2. </span>

<span style="color:green">% Initialize</span>
peak_tol_ratio = .1;  <span style="color:green">% Fraction of max(rows,cols) of image within which a</span>
<span style="color:green">%                         peak is assumed to reside; this helps reduce</span>
<span style="color:green">%                         incorrect line extraction</span>
max_num_lines = 10;  <span style="color:green">% Considers this many popular lines as candidates</span>

[rho_length, theta_length] = size(hough_table);
[rows, cols] = size(bw_image_in);
rho_tol = .1*max(rows,cols);
theta_tol = 10*pi/180;  <span style="color:green">% Tolerence within which two slopes are equal (radians)</span>

rho_out = zeros(1,3);
theta_out = zeros(1,3);
rho = zeros(1,max_num_lines);
theta = zeros(1,max_num_lines);



<span style="color:green">% Apply appropriate threshold</span>
hough_table = hough_table.*( hough_table &gt; threshold );


<span style="color:green">% Identify the most likely max_num_lines lines</span>
i_index = ones(1,max_num_lines);
j_index = ones(1,max_num_lines);

m = 1;
<span style="color:blue">while</span>( m &lt;= max_num_lines )
    
    max_votes = 0;
    <span style="color:blue">for</span> i = 1:rho_length
        <span style="color:blue">for</span> j = 1:theta_length
            <span style="color:blue">if</span>( hough_table(i,j) &gt; max_votes )
                i_index(m) = i;
                j_index(m) = j;
                max_votes = hough_table(i,j);
            <span style="color:blue">end</span>
        <span style="color:blue">end</span>
    <span style="color:blue">end</span>
    
    rho(m) = rho_in(i_index(m));
    theta(m) = theta_in(j_index(m));
    hough_table(i_index(m),j_index(m)) = 0;
    m = m + 1;
    
<span style="color:blue">end</span>


<span style="color:green">% Extract the three most popular lines that fit the geometric criteria for</span>
<span style="color:green">%   the goalpost</span>
rho_out(1) = rho(1);
theta_out(1) = theta(1);

m = 2;

<span style="color:green">%rho_radius = 10;</span>
<span style="color:green">%theta_radius = 5*pi/180;</span>

<span style="color:blue">for</span> i = 2:max_num_lines
    
    <span style="color:green">% If rho, theta do not match within tolerance, then store as the next</span>
    <span style="color:green">%   line</span>
<span style="color:green">%    if( ( (rho(m) - rho(1))/rho_radius)^2 + ( (theta(m) - theta(1))/theta_radius)^2 &gt; 1 )</span>
    <span style="color:blue">if</span>( abs(rho(i) - rho(i-1)) &gt;= 30 )
        rho_out(m) = rho(i);
        theta_out(m) = theta(i);
        m = m + 1;
        <span style="color:blue">if</span>( m &gt; 3 )
            <span style="color:blue">break</span>;
        <span style="color:blue">end</span>
    <span style="color:blue">end</span>
    
<span style="color:blue">end</span>


<span style="color:green">% Determine whether or not the top three lines constitute the goal post</span>
<span style="color:green">%   Note that the Simulink block feeding this function keeps theta between</span>
<span style="color:green">%   +/- pi/2</span>
<span style="color:blue">if</span>( abs(theta_out(1) - theta_out(2)) &lt; theta_tol &amp;&amp; ( max(theta_out(1),theta_out(3)) - min(theta_out(1),theta_out(3)) - pi/2 &lt; theta_tol ) )
    gate_found = 1;
    avg_slope = -( 1/tan(theta_out(1)) + 1/tan(theta_out(2)) )/2;
    y1 = ( (rho_out(1)/cos(theta_out(1))) - (rho_out(3)/cos(theta_out(3))) )*( 1/( tan(theta_out(1)) - tan(theta_out(3)) ) );
    x1 = ( 1/cos(theta_out(1)) )*( rho_out(1) - y1*sin(theta_out(1)) );
    y2 = ( (rho_out(2)/cos(theta_out(2))) - (rho_out(3)/cos(theta_out(3))) )*( 1/( tan(theta_out(2)) - tan(theta_out(3)) ) );
    x2 = ( 1/cos(theta_out(2)) )*( rho_out(2) - y2*sin(theta_out(2)) );
    
<span style="color:blue">elseif</span>( abs(theta_out(1) - theta_out(3)) &lt; theta_tol &amp;&amp; ( max(theta_out(1),theta_out(2)) - min(theta_out(1),theta_out(2)) - pi/2 &lt; theta_tol ) )
    gate_found = 1;
    avg_slope = -( 1/tan(theta_out(1)) + 1/tan(theta_out(3)) )/2;
    y1 = ( (rho_out(1)/cos(theta_out(1))) - (rho_out(2)/cos(theta_out(2))) )*( 1/( tan(theta_out(1)) - tan(theta_out(2)) ) );
    x1 = ( 1/cos(theta_out(1)) )*( rho_out(1) - y1*sin(theta_out(1)) );
    y2 = ( (rho_out(2)/cos(theta_out(2))) - (rho_out(3)/cos(theta_out(3))) )*( 1/( tan(theta_out(2)) - tan(theta_out(3)) ) );
    x2 = ( 1/cos(theta_out(2)) )*( rho_out(2) - y2*sin(theta_out(2)) );
    
<span style="color:blue">elseif</span>( abs(theta_out(2) - theta_out(3)) &lt; theta_tol &amp;&amp; ( max(theta_out(1),theta_out(2)) - min(theta_out(1),theta_out(2)) - pi/2 &lt; theta_tol ) )
    gate_found = 1;
    avg_slope = -( 1/tan(theta_out(2)) + 1/tan(theta_out(3)) )/2;
    y1 = ( (rho_out(1)/cos(theta_out(1))) - (rho_out(2)/cos(theta_out(2))) )*( 1/( tan(theta_out(1)) - tan(theta_out(2)) ) );
    x1 = ( 1/cos(theta_out(1)) )*( rho_out(1) - y1*sin(theta_out(1)) );
    y2 = ( (rho_out(1)/cos(theta_out(1))) - (rho_out(3)/cos(theta_out(3))) )*( 1/( tan(theta_out(1)) - tan(theta_out(3)) ) );
    x2 = ( 1/cos(theta_out(1)) )*( rho_out(1) - y2*sin(theta_out(1)) );
    
<span style="color:blue">else</span>
    gate_found = 0;
    avg_slope = 0;
    
    x1 = 0;
    y1 = 0;
    x2 = 0;
    y2 = 0;
    
<span style="color:blue">end</span>


<span style="color:green">% Determine targeting information (default to center of viewing area if no</span>
<span style="color:green">%   gate found)</span>
<span style="color:blue">if</span>( gate_found ~= 0 )
    
    <span style="color:green">% Determine width and half-height (to center of goal post)</span>
    w = sqrt( (x2 - x1)^2 + (y2 - y1)^2 );
    hh = target_height*gate_aspect_ratio*w;
    
    <span style="color:green">% Project a line "up" (relative to camera) and determine target</span>
    <span style="color:green">%   information</span>
    x12 = (x1 + x2)/2;
    y12 = (y1 + y2)/2;
    
    u = [1 -abs(avg_slope)];
    u = u./norm(u);
    
    target_x = x12 + hh*u(1);
    target_y = y12 + hh*u(2);
    
    
    <span style="color:green">% old code that works, partially</span>
    <span style="color:green">%phi = atan(avg_slope);</span>
    <span style="color:green">%target_x = x12 - hh*cos(phi);</span>
    <span style="color:green">%target_y = y12 - hh*sin(phi);</span>
    
    
    
    
    
    
<span style="color:green">    %{
</span><span style="color:green">    intercept = y12 - avg_slope*x12;
</span><span style="color:green">    
</span><span style="color:green">    a = avg_slope^2 + 1;
</span><span style="color:green">    b = 2*(avg_slope*(intercept - y12) - x12);
</span><span style="color:green">    c = x12^2 + (avg_slope - y12)^2 - hh^2;
</span><span style="color:green">    
</span><span style="color:green">    target_x = real( (-b + sqrt(b^2 - 4*a*c))/(2*a) );
</span><span style="color:green">    target_y = avg_slope*target_x + intercept;
</span><span style="color:green">    %}
</span>    
    
    
    <span style="color:green">% Transform target x, y to global coordinate system</span>
    target_z = target_y - floor(rows/2);
    target_y = target_x - floor(cols/2);
    
<span style="color:blue">else</span>
    
    <span style="color:green">% Default is center of viewing area</span>
    target_x = 0;
    target_y = 0;
    target_z = 0;
    
<span style="color:blue">end</span>


<span style="color:blue">return</span>
</pre></body></html>